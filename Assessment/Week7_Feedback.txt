Starting weekly assessment for Yige, Week7

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 118.59 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: WEEK1, Assessment, WEEK4, project, WEEK7, WEEK8miniProject, WEEK6, .git, WEEK9HPC, WEEK5, WEEK2, WEEK3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~
*.tmp
*.temp
*.docx
*.jpeg
*.RData
*.Rhistory

*.png
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# **CMEE Repository**

> by Yige Sun   --MRes.CMEE 2019-20

This repository is for my MRes.CMEE course.  Including courseworks, practicals, proposals etc.


![](https://pic2.zhimg.com/737434d0c6b06a6ef29684c754790019_1200x500.jpg)
## **Structure**
All the files were classified by [WEEK] .
Each week contains

[code]:
scripts in .sh, .py .R or other types; 

[data]:
data files that been used or can be used by scripts; 

[sandbox]: are for fun, that's where I play with(or torture) myself.

[results]:where the outputs stored

## **Environment**

ubuntu 18.04.3 

GNU bash, version 4.4.20

R version 3.6.1

ipython3 version 5.5.0


## **Contents**

### [**WEEK1**](https://github.com/ys219/CMEECoursework/tree/master/WEEK1)

Unix basics

Shell Scripts

LaTex

### [**WEEK2**](https://github.com/ys219/CMEECoursework/tree/master/WEEK2)

Python week I

### [**WEEK3**](https://github.com/ys219/CMEECoursework/tree/master/WEEK3)

R week

### [**WEEK4**](https://github.com/ys219/CMEECoursework/tree/master/WEEK4)

Statistics Analysis

### [**WEEK5**](https://github.com/ys219/CMEECoursework/tree/master/WEEK5)

GIS in R

### [**WEEK6**](https://github.com/ys219/CMEECoursework/tree/master/WEEK6)

Genomics applications

### [**WEEK7**](https://github.com/ys219/CMEECoursework/tree/master/WEEK7)

Python week II

### [**WEEK8miniProject**](https://github.com/ys219/CMEECoursework/tree/master/WEEK8miniProject)

Mini Project Heckathon

### [**WEEK9HPC**](https://github.com/ys219/CMEECoursework/tree/master/WEEK9HPC)

Neutral Theory, Coalescence, HPC, fractal

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 9 weekly directories: WEEK1, WEEK2, WEEK3, WEEK4, WEEK5, WEEK6, WEEK7, WEEK8miniProject, WEEK9HPC

The Week7 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK7...

Found the following directories: code, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
CMEECoursework WEEK7
==
This directory includes my code, data, results of exercises and practical in CMEE week7

## Contents:

### `06 Biological Computing in Python II`

### [**code**](https://github.com/ys219/CMEECoursework/tree/master/WEEK7/code)

### Practicals:

#### `LV1.py`

solving the Lotka-Volterra model for a predator-prey
system in two dimensional space

#### `LV2.py`

solving the Lotka-Volterra model for a predator-prey
system in two dimensional space, modified from LV1 

#### `LV3.py`

solving the Lotka-Volterra model for a predator-prey
system in two dimensional space, with discrete time.

#### `LV4.py`

solving the Lotka-Volterra model for a predator-prey
system in two dimensional space, with discrete time and epsilon

#### `LV5.py`

solving the Lotka-Volterra model for a predator-prey
system in two dimensional space, with discrete timeand epsilon

#### `run_LV.py`

the script that run the LV1.py, LV2.py, LV3.py files.

#### `DrawFw.py`

plot food web network and save it


#### `Nets.py`

a python version that draw network as Nets.R

#### `regexs.py`

practices of regexs

#### `blackbirds`

the solution for black bird problem

#### `using_os.py`

the tasks to use os


#### `fmr.R`

the R file for run_fmr_R.py


#### `run_fmr_R.py`

the script that run the fmr.R file


### Exercises:

#### `profileme.py`

profiling practices

#### `profileme2.py`

alternative way of profiling practices



#### `TestR.py`

python script that run the TestR.R, 


#### `TestR.R`

the R file be ran by the TestR.py

#### `Timeitme.py`

how long would it takes to run certain file.



**********************************************************************

Data directory missing!

Found following files in results directory: FWnetwork.pdf, LV1_models.pdf, LV2_models.pdf, QMEENet_by_py.svg, LV3_models.pdf...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 14 code files: TestR.py, regexs.py, LV3.py, profileme2.py, timeitme.py, Nets.py, profileme.py, LV4.py, using_os.py, LV5.py, DrawFW.py, Nets.R, run_fmr_R.py, run_LV.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TestR.py...

File contents are:
**********************************************************************
#!/bin/env python3


"""profiling and export outputs"""

# __appname__=="TestR"
# __author__=="YSun"
# __version__=="0.01"
# __liscence__=="code.program"

import subprocess

subprocess.Popen("Rscript --verbose TestR.R > ../results/TestR.Rout 2> ../results/TestR_errFile.Rout", shell=True).wait()

subprocess.Popen("Rscript --verbose NonExistScript.R > ../results/outputFile.Rout 2> ../results/errorFile.Rout", shell=True).wait()
##complile R and save the outcomes**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06025s

======================================================================
Inspecting script file regexs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
_appname_="regexs"
_author_="ys"
_version_="0.0.1"
_license_="code.program"
import re
"""regex practices"""

MyStr = 'an example'
match = re.search(r'\w*\s', MyStr) # match character that followed by space

if match:                      
    print('found a match:', match.group()) 
else:
    print('did not find a match')    

match = re.search(r'2', "it takes 2 to tango")# match '2'
match.group()

match = re.search(r'\d', "it takes 2 to tango")# match numeric character
match.group()

match = re.search(r'\d.*', "it takes 2 to tango")# match numeric character and whatever the following.
match.group()

match = re.search(r'\d.', "it takes 2 to tango")# match the numeris character and the one character following.
match.group()

match = re.search(r'\s\w{1,3}\s', "once upon a time") # match characters the in between two spaces and length is in between 1-3
match.group()


match = re.search(r'\s\w*$', "once upon a time")# find a space a character what ever in the middle and the end
match.group()


re.search(r'\w*\s\d.*\d', 'take 2 grams of H2O').group() # find a bunch of characters followed by a space, a numeric cha, whatever thingsend up with a numeric cha

re.search(r'^\w*.*\s', 'once upon a time').group() # find the start, a bunch of character, what ever in between and a space.

re.search(r'<.+>', 'This is a <EM>first</EM> test').group() # find the characters or space in bewtwen <>

re.search(r'<.+?>', 'This is a <EM>first</EM> test').group() # find the character between <>, repeat only once(i.e. 2 characters/spaces)

re.search(r'\d*\.?\d*','1432.75+60.22i').group() # find the bunch of numbers with one/ zero "." in the middle and end with a number.

re.search(r'[AGTC]+', 'the sequence ATTCGT').group() # match any character listed(without space or number in between)

re.search(r'\s+[A-Z]\w+\s*\w+', "The bird-shit frog's name is Theloderma asper.").group() # find a space, a capital letter, a bunch of characters, 

MyStr = 'Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory'
match = re.search(r"[\w\s]+,\s[\w\.@]+,\s[\w\s]+",MyStr)# find any s[ace or characters,a comma, a space, any charracters+.+@
match.group()

MyStr = 'Samraat Pawar, s-pawar@imperial.ac.uk, Systems biology and ecological theory'


match = re.search(r"[\w\s]?,\s[\w\.-]+@[\w\.-]+,\s[\w\s&]+",MyStr)
match.group()


    # Try the regex we used above for finding names ([\w\s]+) for cases where the person's name has something unexpected, 
    # like a ? or a +. Does it work? 
    # How can you make it more robust?
    ###by including the potential symbols in the name to the regex, e.g. [\w\s\+\?\.]

    # Translate the following regular expressions into regular English:
    #     r'^abc[ab]+\s\t\d'
    ##    match the start of string, match exactly "abc", match "a" or "b" one or more times, a space, match a tab, match a integer

    #     r'^\d{1,2}\/\d{1,2}\/\d{4}$'
    ##    [match a date]match the start of string, match integers at least 1 but no more than 2 times, match a slash, match a integer 1 or 2 times, match a slash, ainteger 4 times, the end
    #     r'\s*[a-zA-Z,\s]+\s*'
    ##    match a space several times, any characters including upper lower space comma space multiple times, a space, the end.

    # Write a regex to match dates in format YYYYMMDD, making sure that:
    #     Only seemingly valid dates match (i.e., year greater than 1900)
    #     First digit in month is either 0 or 1
    #     First digit in day ≤3


re.search(r'19|20\d{2}(0[1-9]|1[0-2])(0[1-9]|[1|2]\d|3[0-1])',"20090101").group()

####3 grouping regex patterns 
MyStr = 'Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory'
match = re.search(r"[\w\s]+,\s[\w\.-]+@[\w\.-]+,\s[\w\s&]+",MyStr)
match.group()
match.group(0)
match = re.search(r"([\w\s]+),\s([\w\.-]+@[\w\.-]+),\s([\w\s&]+)",MyStr)
if match:
    print(match.group(0))
    print(match.group(1))
    print(match.group(2))
    print(match.group(3))

####finding all matches

MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a-academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a_academic@imperial.ac.uk, Some other stuff thats even more boring"
emails = re.findall(r'[\w\.-]+@[\w\.-]+', MyStr) 
for email in emails:
    print(email)
# first use re.findall to match all the strings
# then use loop the print all the strings that you are looking for in the long string.
emails

#### finding files
f= open("../data/TestOaksData.csv",'r')

found_oaks = re.findall(r"Q[\w\s].*\s", f.read())
# read the file and match the words start with Q that followed by a character or space and any thing except new line break
# end up with a space.

found_oaks

#### group with multiple matches:
MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a.academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a.academic@imperial.ac.uk, Some other stuff thats even more boring"

found_matches = re.findall(r'([\w\s]+),\s([\w\.-]+@[\w\.-]+)', MyStr)
found_matches
#### find all matches of: character or spaces, a comma, a space followed by characters or dot or dash more than onces
# , at symbol , characters or dot or dash more than onces from the string.

for item in found_matches:
    print(item)

#### exxtracting text from webpages:
import urllib3

conn =  urllib3.PoolManager()
r = conn.request('GET', 'https://www.imperial.ac.uk/silwood-park/academic-staff/') 
webpage_html = r.data 

type(webpage_html)

My_Data = webpage_html.decode()
print(My_Data)

pattern= r'Dr\s+\w+\s+\w+|Pro\w+\s+\w+\s+\w+'
regex = re.compile(pattern)
for match in regex.finditer(My_Data):
    print(match.group())
##### replace text
New_Data = re.sub(r'\t',' ',My_Data)


**********************************************************************

Testing regexs.py...

regexs.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
found a match: an 
Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory
Samraat Pawar
s.pawar@imperial.ac.uk
Systems biology and ecological theory
s.pawar@imperial.ac.uk
a-academic@imperial.ac.uk
y.a_academic@imperial.ac.uk

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "regexs.py", line 107, in <module>
    f= open("../data/TestOaksData.csv",'r')
FileNotFoundError: [Errno 2] No such file or directory: '../data/TestOaksData.csv'

======================================================================
Inspecting script file LV3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" a discrete-time version of the LV model """
_appname_="LV3"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

def LV3 ():
    """a discrete-time version of the LV model"""
    import scipy as sc
    import scipy.integrate as integrate
    import sys

    def CR_t1(pops, t = 0):
        """a discrete-time version of the LV model
        with iteration"""
        Rt = pops[0]
        Ct = pops[1]
        Rt1 = Rt*(1 + r * (1-Rt / k) - a * Ct )
        Ct1 = Ct*(1 - z + e * a * Rt)

        return sc.array([Rt1,Ct1])


### main inputs:
    if len(sys.argv) != 5:
        r = 1.0
        a = 0.1
        z = 1.5
        e = 0.75
        print("using default parameters")
    else:
        r = float(sys.argv[1])
        a = float(sys.argv[2])
        z = float(sys.argv[3])
        e = float(sys.argv[4])

    k = 30#define constant parameter, without exceeding the carrying capacity
    t = sc.linspace(0, 15, 20)#define time series(1000 number between 0-15)
    ## generate data
    R0 = 10
    C0 = 5 
    RC0 = sc.array([R0, C0])
    pops = sc.zeros((len(t),2))

    for i in range(0,len(t)):
        pops[i] = RC0
        RC0 = CR_t1(RC0,t=t)

    print("the final population density is\n",str(pops[-1,0]),"for Resourses\n",pops[-1,1],"for Consumers")




    import matplotlib.pylab as p
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    with PdfPages("../results/LV3_models.pdf")as pdf:
    

        f1 = p.figure()

        p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
        p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Time')
        p.ylabel('Population density')
        p.title('Consumer-Resource population dynamics\n(Discrete-time)')
        
        pdf.savefig(f1) #Save figure

        f2 = p.figure()

        p.plot(pops[:,0], pops[:,1]  , 'r-')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Resource density')
        p.ylabel('Consumer density')
        p.title('Consumer-Resource population dynamics\n(Discrete time)\nr=%s,a=%s,z=%s,e=%s,k=%s'%(r,a,z,e,k))

        pdf.savefig(f2)#Save figure


LV3()
**********************************************************************

Testing LV3.py...

LV3.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
using default parameters
the final population density is
 19.1666125773 for Resourses
 3.79917302015 for Consumers

**********************************************************************

Code ran without errors

Time consumed = 0.77729s

======================================================================
Inspecting script file profileme2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""alternative way of profiling practices"""
_appname_="profileme2"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

def my_squares(iters):
    """practice"""
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    """practice"""
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    """practice"""
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")

##defining fuctions for profiling**********************************************************************

Testing profileme2.py...

profileme2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 3.63482s

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#!/bin/env python3

"""how long would it takes"""
_appname_="timtimte"
_author_="ys"
_version_="0.0.1"
_license_="code.program"


##############################################################################
# loops vs. list comprehensions: which is faster?
##############################################################################

iters = 1000000

import timeit

from profileme import my_squares as my_squares_ex

from profileme2 import my_squares as my_squares_im

# %timeit my_squares_loops(iters)
# %timeit my_squares_lc(iters)


##############################################################################
# loops vs. the join method for strings: which is faster?
##############################################################################

mystring = "my string"

from profileme import my_join as my_join_join

from profileme2 import my_join as my_join

# %timeit(my_join_join(iters, mystring))
# %timeit(my_join(iters, mystring))
import time 

start1 = time.time()#starting time point
my_squares_ex(iters)#run the loop
print("The explicit loops take %f seconds to run" % (time.time()-start1))

start2 = time.time()#starting time point
my_squares_im(iters)
print("The implicit loops take %f seconds to run" % (time.time()-start2))
**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00355s

======================================================================
Inspecting script file Nets.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
_appname_="Nets"
_author_="ys"
_version_="0.0.1"
_license_="code.program"
# Author: Y_Sun ys219@ic.ac.uk

"""python script that recreat the outcome of Nets.R"""

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt 

edge = pd.read_csv("../data/QMEE_Net_Mat_edges.csv")
node = pd.read_csv("../data/QMEE_Net_Mat_nodes.csv")
ids = list(node.id)
##load data and generate the ids

AdjList = []
#empty list for edge data

for i in range(len(edge)):
    for j in range(len(edge)):
        if edge.iloc[i][j] != 0 and i<j:
            AdjList.append((edge.columns[i],edge.columns[j],edge.iloc[i][j]))
## get directionalities and get rig of 0s, and repeated(ie. (icl,ceh)&(ceh,icl) keep only one) , and diagnals.

edgewidth = [i[2]/10+0.5 for i in AdjList]

nodescol = []
## empty list for nodes colours
for i in node.Type:
    if i == "University":
        nodescol.append("blue")
    elif i =="Hosting Partner":
        nodescol.append("green")
    else:
        nodescol.append("red")      

f = plt.figure()


## nodes layout
G = nx.Graph()
G.add_nodes_from(ids)
G.add_weighted_edges_from(tuple(AdjList))
## define the nodes and edge length

nx.draw_networkx(G,node_size = 2000, node_color = nodescol, edge_color = "grey",width = edgewidth)
## main network plot

red, = plt.plot([],"ro",markersize = 10)
green, = plt.plot([],"go",markersize = 10)
blue, = plt.plot([],"bo",markersize = 10)
plt.legend([red, green, blue,], ["Non-Hosting Partners","Hosting Partner", "University"], loc= "best")
## set the legend "ro","bo"for red dots blue dots

f.savefig("../results/QMEENet_by_py.svg", width = 10, height = 10)

**********************************************************************

Testing Nets.py...

Nets.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "Nets.py", line 14, in <module>
    edge = pd.read_csv("../data/QMEE_Net_Mat_edges.csv")
  File "/usr/lib/python3/dist-packages/pandas/io/parsers.py", line 498, in parser_f
    return _read(filepath_or_buffer, kwds)
  File "/usr/lib/python3/dist-packages/pandas/io/parsers.py", line 275, in _read
    parser = TextFileReader(filepath_or_buffer, **kwds)
  File "/usr/lib/python3/dist-packages/pandas/io/parsers.py", line 590, in __init__
    self._make_engine(self.engine)
  File "/usr/lib/python3/dist-packages/pandas/io/parsers.py", line 731, in _make_engine
    self._engine = CParserWrapper(self.f, **self.options)
  File "/usr/lib/python3/dist-packages/pandas/io/parsers.py", line 1103, in __init__
    self._reader = _parser.TextReader(src, **kwds)
  File "pandas/parser.pyx", line 353, in pandas.parser.TextReader.__cinit__ (pandas/parser.c:3246)
  File "pandas/parser.pyx", line 591, in pandas.parser.TextReader._setup_parser_source (pandas/parser.c:6111)
OSError: File b'../data/QMEE_Net_Mat_edges.csv' does not exist

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""profiling test"""
_appname_="profileme"
_author_="ys"
_version_="0.0.1"
_license_="code.program"



def my_squares(iters):
    """practice"""
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    """practice"""
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    """practice"""
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 6.42267s

======================================================================
Inspecting script file LV4.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" a discrete-time version of the LV model """
_appname_="LV4"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

def LV4 ():
    """a discrete-time version of the LV model"""
    import scipy as sc
    import scipy.stats as stats
    import scipy.integrate as integrate
    import sys

    def CR_t1(pops, t = 0):
        """a discrete-time version of the LV model
        with iteration"""
        Rt = pops[0]
        Ct = pops[1]
        eps = stats.norm.rvs(0.2, size = 1)[0]
        Rt1 = Rt*(1 + (r + eps)* (1-Rt / k) - a * Ct )
        Ct1 = Ct*(1 - z + e * a * Rt)

        return sc.array([Rt1,Ct1])


### main inputs:
    if len(sys.argv) != 5:
        r = 1.0
        a = 0.1
        z = 1.5
        e = 0.75
        print("using default parameters")
    else:
        r = float(sys.argv[1])
        a = float(sys.argv[2])
        z = float(sys.argv[3])
        e = float(sys.argv[4])

    k = 30#define constant parameter, without exceeding the carrying capacity
    t = sc.linspace(0, 15, 20)#define time series(1000 number between 0-15)
    ## generate data
    R0 = 10
    C0 = 5 
    RC0 = sc.array([R0, C0])
    pops = sc.zeros((len(t),2))

    for i in range(0,len(t)):
        pops[i] = RC0
        RC0 = CR_t1(RC0,t = t)


    print("the final population density is\n",str(pops[-1,0]),"for Resourses\n",pops[-1,1],"for Consumers")


    import matplotlib.pylab as p
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    with PdfPages("../results/LV4_models.pdf")as pdf:
    

        f1 = p.figure()

        p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
        p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Time')
        p.ylabel('Population density')
        p.title('Consumer-Resource population dynamics\n(Discrete-time)')
        
        pdf.savefig(f1) #Save figure

        f2 = p.figure()

        p.plot(pops[:,0], pops[:,1]  , 'r-')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Resource density')
        p.ylabel('Consumer density')
        p.title('Consumer-Resource population dynamics\n(Discrete time)\nr=%s,a=%s,z=%s,e=%s,k=%s'%(r,a,z,e,k))

        pdf.savefig(f2)#Save figure


LV4()
**********************************************************************

Testing LV4.py...

LV4.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
using default parameters
the final population density is
 -2825665.02524 for Resourses
 418820.447289 for Consumers

**********************************************************************

Code ran without errors

Time consumed = 0.91238s

======================================================================
Inspecting script file using_os.py...

File contents are:
**********************************************************************
#!/bin/env python3

_appname_="usingos"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

"""some tasks to complete"""


# Use the subprocess.os module to get a list of files and  directories 
# in your ubuntu home directory 

# Hint: look in subprocess.os and/or subprocess.os.path and/or 
# subprocess.os.walk for helpful functions

import subprocess
import re

#################################
#~Get a list of files and 
#~directories in your home/ that start with an uppercase 'C'

# Type your code here:

# Get the user's home directory.
home = subprocess.os.path.expanduser("~")
# Create a list to store the results.
FilesDirsStartingWithC = []

# Use a for loop to walk through the home directory.
for (dir, subdir, files) in subprocess.os.walk(home):  
#################################
# Get files and directories in your home/ that start with either an 
# upper or lower case 'C'
# Type your code here:
    FilesDirsStartingWithC.extend(re.findall(r'/[Cc]\w*/',str(dir)))
    FilesDirsStartingWithC.extend(re.findall(r'/[Cc]\w*/',str(subdir)))
    FilesDirsStartingWithC.extend(re.findall(r'/[Cc]\w*\W\w*/',str(files)))


FilesDirsStartingWithC=set(FilesDirsStartingWithC)
print(FilesDirsStartingWithC)
#################################
# Get only directories in your home/ that start with either an upper or 
#~lower case 'C' 

# Type your code here:
HomeDirWithC=[]
for (dir, subdir, files) in subprocess.os.walk(home):  
    HomeDirWithC.extend(re.findall(r'home/[Cc]\w*/',str(dir)))


HomeDirWithC=set(HomeDirWithC)
print(HomeDirWithC)**********************************************************************

Testing using_os.py...

using_os.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
{'/concurrent/', '/Compiled/', '/CWeek/', '/code/', '/CMEE_Talk/', '/CERRONE/', '/calendar/', '/CS395T/', '/Cecile/', '/cutils/', '/CorrectedNewCerrado/', '/CiliatesOld/', '/CarnivoreOnly/', '/corebird/', '/cryptiles/', '/clipres/', '/chokidar/', '/contents/', '/coregrind/', '/chalkboard/', '/CMEE_Exams/', '/constantinople/', '/callgrind/', '/categories/', '/CMEE_Intro_Talk/', '/Comments/', '/Cartola/', '/Cluster/', '/coverage/', '/CVs/', '/Crydajam/', '/corecheck/', '/cSbw5/', '/Column1/', '/cme
**********************************************************************

Code ran without errors

Time consumed = 3.41674s

======================================================================
Inspecting script file LV5.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
""" a discrete-time version of the LV model """
_appname_="LV5"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

def LV5 ():
    """a discrete-time version of the LV model"""
    import scipy as sc
    import scipy.stats as stats
    import scipy.integrate as integrate
    import sys

    def CR_t1(pops, t = 0):
        """a discrete-time version of the LV model
        with iteration"""
        Rt = pops[0]
        Ct = pops[1]
        eps = stats.norm.rvs(0.02, size = 1)[0]
        Rt1 = Rt*(1 + r + eps + (1-Rt / k) - a * Ct )
        Ct1 = Ct*(1 - z + eps +e * a * Rt)

        return sc.array([Rt1,Ct1])


### main inputs:
    if len(sys.argv) != 5:
        r = 0.5
        a = 0.05
        z = 0.7
        e = 0.5
        print("using default parameters")
    else:
        r = float(sys.argv[1])
        a = float(sys.argv[2])
        z = float(sys.argv[3])
        e = float(sys.argv[4])

    k = 20#define constant parameter, without exceeding the carrying capacity
    t = sc.linspace(0, 15, 15)#define time series(15 number between 0-15)
    ## generate data
    R0 = 10
    C0 = 5 
    RC0 = sc.array([R0, C0])
    pops = sc.zeros((len(t),2))

    for i in range(0,len(t)):
        pops[i] = RC0
        RC0 = CR_t1(RC0,t = t)

    print("the final population density is\n",str(pops[-1,0]),"for Resourses\n",pops[-1,1],"for Consumers")


    import matplotlib.pylab as p
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    with PdfPages("../results/LV5_models.pdf")as pdf:
    

        f1 = p.figure()

        p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
        p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Time')
        p.ylabel('Population density')
        p.title('Consumer-Resource population dynamics\n(Discrete-time)')
        
        pdf.savefig(f1) #Save figure

        f2 = p.figure()

        p.plot(pops[:,0], pops[:,1]  , 'r-')
        p.grid()
        p.legend(loc='best')
        p.xlabel('Resource density')
        p.ylabel('Consumer density')
        p.title('Consumer-Resource population dynamics\n(Discrete time)\nr=%s,a=%s,z=%s,e=%s,k=%s'%(r,a,z,e,k))

        pdf.savefig(f2)#Save figure


LV5()
**********************************************************************

Testing LV5.py...

LV5.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
using default parameters
the final population density is
 -2.10893507152e+234 for Resourses
 -5.5706952966e+229 for Consumers

**********************************************************************

Encountered error (or warning):
LV5.py:21: RuntimeWarning: overflow encountered in double_scalars
  Rt1 = Rt*(1 + r + eps + (1-Rt / k) - a * Ct )
LV5.py:22: RuntimeWarning: overflow encountered in double_scalars
  Ct1 = Ct*(1 - z + eps +e * a * Rt)

======================================================================
Inspecting script file DrawFW.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Plot food web network and save it"""
_appname_="DrawFW"
_author_="ys"
_version_="0.0.1"
_license_="code.program"
import networkx as nx

import scipy as sc

import matplotlib.pyplot as p

def GenRdmAdjList(N = 2, C = 0.5):
    """ 
generate ramdon list
    """
    Ids = range(N)
    ALst = []
    for i in Ids:
        if sc.random.uniform(0,1,1) < C:
            Lnk = sc.random.choice(Ids,2,replace=False).tolist()
            # if Lnk[0] != Lnk[1]: #avoid self (e.g., cannibalistic) loops
            ALst.append(Lnk)
    
    return ALst


#c is the probablity of observe a connection btwn two random things. In nature it is 10-20%
###things in nature usually shown in log scale as it could be really dramatically vary in size
MaxN = 30
c = 0.75

AdjL = sc.array(GenRdmAdjList(MaxN , c))
AdjL

Sps = sc.unique(AdjL)
SizRan = ([-10,10])
Sizs =  sc.random.uniform(SizRan[0],SizRan[1],MaxN)
Sizs



pos = nx.circular_layout(Sps)

G = nx.Graph()

G.add_nodes_from(Sps)

G.add_edges_from(tuple(AdjL))

NodSizs = 1000 * (Sizs-min(Sizs))/(max(Sizs)-min(Sizs))

nx.draw_networkx(G, pos, node_size= NodSizs, node_color="red", edge_color="black")
p.savefig("../results/FWnetwork.pdf")

**********************************************************************

Testing DrawFW.py...

DrawFW.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:522: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(edge_color) \
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:543: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if cb.is_string_like(edge_color) or len(edge_color) == 1:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:724: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(label):

======================================================================
Inspecting script file Nets.R...

File contents are:
**********************************************************************
library(igraph) # Load the igraph package

rm(list = ls())

# 	ICL	UoR	CEH	ZSL	CEFAS	Nonacademic/CASE
# ICL	0	0	10	9	5	70
# UoR		0	12	0	2	76
# CEH			0	0	0	6
# ZSL			       0 	0	28
# CEFAS			       0	0
# Nonacademic/CASE                        0

links <- read.csv("../data/QMEE_Net_Mat_edges.csv", header=T, as.is=T)
nodes <- read.csv("../data/QMEE_Net_Mat_nodes.csv", header=T, row.names = 1)

#Create graph object
net <- graph.adjacency(as.matrix(links), mode = "directed", weighted=TRUE, diag=F)
        
#Test plot
# plot(net, edge.arrow.size=1, edge.curved=.1,
#      vertex.color="orange", vertex.frame.color="#555555",
#      vertex.label=V(net)$Type, vertex.label.color="black",
#      vertex.label.cex=.7) 

# Generate colors based on partner type:
colrs <- c("green", "red", "blue")
V(net)$color <- colrs[nodes$Type]

# Set node size based on Number of PIs:
# V(net)$size <- V(net)$Pis*0.9

V(net)$size <- 50

# Set edge width based on weight (PhD Students):
E(net)$width <- E(net)$weight

#change arrow size and edge color:
E(net)$arrow.size <- 1
E(net)$edge.color <- "gray80"

E(net)$width <- 1+E(net)$weight/10

graphics.off()

svg("../results/QMEENet.svg",width=7,height=7)

plot(net, edge.curved=0, vertex.label.color="black") 

legend(x=-1.5, y=-0.1, c("Hosting Partner", "Non-hosting Partner", "University"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)

dev.off()
**********************************************************************

Testing Nets.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Loading required package: methods

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/QMEE_Net_Mat_edges.csv': No such file or directory
Execution halted

======================================================================
Inspecting script file run_fmr_R.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""script to run fmr.R"""
_appname_="run_fmr"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

import subprocess
try:
    subprocess.Popen("Rscript --verbose fmr.R", shell=True).wait()
    print("\npython says: 'Yay!! The run was sccessful'")
except:
    print("\npython says: 'Opps! The run was unsccessful'")
##use try to mute the error and print the status**********************************************************************

Testing run_fmr_R.py...

run_fmr_R.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Fatal error: cannot open file 'fmr.R': No such file or directory

python says: 'Yay!! The run was sccessful'

**********************************************************************

Encountered error (or warning):
running
  '/usr/lib/R/bin/R --slave --no-restore --file=fmr.R'


======================================================================
Inspecting script file run_LV.py...

File contents are:
**********************************************************************
#!/bin/env python3

"""profiling and export outputs"""
_appname_="run_LV"
_author_="ys"
_version_="0.0.1"
_license_="code.program"


import cProfile
import pstats

import LV1
import LV2
import LV3
import LV4
import LV5
##import the script as module



cProfile.run("LV1.LV1()", filename= "../results/LV1_prof.out")
cProfile.run("LV2.LV2()", filename= "../results/LV2_prof.out")
cProfile.run("LV3.LV3()", filename= "../results/LV3_prof.out")
cProfile.run("LV4.LV4()", filename= "../results/LV4_prof.out")
cProfile.run("LV5.LV5()", filename= "../results/LV5_prof.out")
## call the functions in scripts and save output profile time

LV1p = pstats.Stats("../results/LV1_prof.out")
LV2p = pstats.Stats("../results/LV2_prof.out")
LV3p = pstats.Stats("../results/LV3_prof.out")
LV4p = pstats.Stats("../results/LV4_prof.out")
LV5p = pstats.Stats("../results/LV5_prof.out")
## read the output file.

print("**********LV1 profile***************")
LV1p.strip_dirs().sort_stats("tottime","cumulative").print_stats(5)
print("**********LV2 profile***************")
LV2p.strip_dirs().sort_stats("tottime","cumulative").print_stats(5)
print("**********LV3 profile***************")
LV3p.strip_dirs().sort_stats("tottime","cumulative").print_stats(5)
print("**********LV4 profile***************")
LV4p.strip_dirs().sort_stats("tottime","cumulative").print_stats(5)
print("**********LV5 profile***************")
LV5p.strip_dirs().sort_stats("tottime","cumulative").print_stats(5)

# strip_dirs(), remove irrelevent path; sort_stats,sort by working time and total time, print_stats, print first 5 lines
# cprofile usage and analysis tool: http://yunpiao.pub/2017/03/22/Python/2017-2-10%20python%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%20cProfile/**********************************************************************

Testing run_LV.py...

run_LV.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "run_LV.py", line 13, in <module>
    import LV1
ImportError: No module named 'LV1'

======================================================================
======================================================================
Finished running scripts

Ran into 7 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!