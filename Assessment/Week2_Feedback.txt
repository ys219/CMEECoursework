Starting weekly assessment for Yige, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.55 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: WEEK1, Assessment, .git, WEEK2, WEEK3

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.docx 
*.pdf 
*.jpeg
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
###########################
#CMEECoursework Repository#
###########################

this repository includs codes and data that have been run and used in CMEE bootcamp
All the codes [until 11th Oct. 2019] were written and tested with ubuntu 18.04.3 terminal, python3.* 
please provide feedbacks and suggestions, I really appreciate it.

#############
#Directories#
#############
All the files were classified by weeks, under each [WEEK] dircetory there are [code] directoy which contains scripts in .sh, .txt or other types; 
[data] directory which contains data files that been used or can be used by scripts; 
[sandbox] are for fun, that's where I play with(or torture) myself.
under each [WEEK] directory, there is a seperate README.txt to give an overview of contents in the directory.



**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: WEEK1, WEEK2, WEEK3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: code, sandbox, data, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
CMEECoursework WEEK2
==
This directory includes my code and data of exercises and practical in CMEE bootcamp week2


## Contents:

##### 05Python_I


## Practicals:

#### `lc1.py`
/code 

An exercise for writing comprehension and conventional loops with given vaiables


#### `lc2.py`
/code

An exercise that look for sepcific tuples or data with comprehension and conventional loops with given variables

#### `dictionary.py`
/code

creating dictionary with given list, and put multiple values in a set for a single key

#### `tuples.py`
/code

split up given list into seperate lines with new line characters 

#### `cfexercises1.py`
/code

modified foo_* to control flow, with running the script, all the foo_* would be imported and automatically show the output of  

#### `align_seqs.py`
/code

align and calculate the best score with given sequences saved in a csv file --> ../data/twosequences.csv, the path is in the script

#### `align_seqs_fasta.py`
/code

align and calculate the best score with sequences saved in a fasta files --> ../data/*.csv, the path could be input from terminal or use the default path that wirrten in script already.

#### `oaks_debugme.py`
/code

read file from ../data/TestOaksData.csv and import the data then look out the genus quercus from the list, then extract the latin name of all oaks and save in a new csv file ../data/JustOaksData.csv



## Exercises:

#### `basic_csv.py`
/code

A script that can open and read csv file from ../data/testcsv.csv extract certain coloum them save as a new csv file, ../data/bodynass.csv

#### `basic_io1.py`
/code

A script that can open a text file --> ../sandbox/test.txt and print the lines

#### `basic_io2.py`
/code

A script that write every number in a new line and save them into a txt file --> ../sandbox/testout.txt

#### `basic_io3.py`
/code

use package pickle to save a contents as binary file save and export in ../sandbox/test.p then try to open it with pickle as well


#### `boilerplate.sh`
/code

A script that can examine how sys and  __name__="__main__" work in the terminal and allow the script run from the terminal

#### `cfexercises2.py`
/code

A script with conventional loops to print multiple "hello", I have modified it into a control flow therefore it can be run in terminal.

#### `control_flow.py`
/code

Defined several functions, and turn to a control flow. Number for calculation can be input from terminal, it will automatiically return serverl output too.

#### `debugme.py`
/code

this script is written for testing ipdb package, It wouldn't able to be as 0 could not be a division.

#### `loops.py`
/code

A script with several conventional loops exercises

#### `oaks.py`
/code

Using comprehension and conventioanl loops to manipulate the elements in list with uppercase, lower case or simply print tehm out etc.

#### `scope.py`
/code

An exersice to clarify what is global and what is local variable, with print out lines it illustrate the current global and local variable for each name.

#### `sysargv.py`
/code

A script that can practice the input variable from the terminal and print the out from python

#### `test_control_flow.py`
/code

A script that exercise doctest function which is veery handy for debugging.

#### `using_name.py`
/code

An exercise to practice and look at running script with different methods and how they interact with sys.argv

**********************************************************************

Found following files in results directory: alignment_output.txt, alignment_better_output.p, alignment_fasta_output.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 23 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************


# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
)
# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
rainfall100=[(i[0],i[1]) for i in rainfall if i[1]>100] 
print(rainfall100)
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 
rainfall50=[i[0] for i in rainfall if i[1]<50] 
print(rainfall50)
# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

for i in [50,100]:
    if i==100:
        r100=[(a[0],a[1]) for a in rainfall if a[1]>i]
        print(r100)
    else:
        r50=[a[0] for a in rainfall if a[1]<i]
        print(r50)

**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 99

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]

**********************************************************************

Code ran without errors

Time consumed = 0.03909s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""Description of this program or application.
you can use several line"""

_appname_="boilerplate"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

import sys

def main(argv):
    """main entry point of the program"""
    print('This is a boillerplate')
    return 0

if __name__ == "__main__":
    """make sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boillerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03603s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()

# write a file containing only species name and Body mass
f = open('../data/testcsv.csv','r')
g = open('../data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
print("\n")
print(temp)
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 98

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03331s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/binenv python3
"""these functions combined loops and confitionals and allow you print lots of hello"""
import sys

def hello_1(x=12) :
    """hello_1 allows you print hello at the all 3a that smaller than input number"""
    for j in range(12):
        if j % 3 == 0:
            print('hello')

def hello_2(x=15) :
    """hello_2 allows you print hello at 4a+3 or 5a+3 that smaller than x"""
    for j in range(x):
        if j % 5 ==3:
            print('hello')
        elif j %4 ==3:
            print('hello')

def hello_3(x=15):
    """hello_3 allows you print hello at 3a that smaller than x"""
    z=0
    while z <=x:
        print('hello')
        z=z+3

def hello_4(x=100):
    """hello_4 allows you print 1 hello when x is greater than 18, and 7 more hello when it greater than 31 """
    z=12
    while z<x:
        if z== 31:
            for k in range(7) :
                print("hello")
        elif z==18:
            print('hello')
        z=z+1

def main(argv):
    print(hello_1(18))
    print(hello_2(20))
    print(hello_3(20))
    print(hello_4(120))
    return None

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
None
hello
hello
hello
hello
hello
hello
hello
hello
None
hello
hello
hello
hello
hello
hello
hello
None
hello
hello
hello
hello
hello
hello
hello
hello
None

**********************************************************************

Code ran without errors

Time consumed = 0.03163s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""This scrpit can work out the matches of two alignments, and out put the best match"""
import sys
import pickle

if len(sys.argv) == 3:
    with open(sys.argv[1],'r') as fasta_file1:
    # seq1=fasta_file1.readlines()
    # seq1=str(seq1)
    # seq1=seq1.strip('\n')
        seq1 = ""
        headerline = True
        for row in fasta_file1:
            if headerline:
                headerline = False
            else:
                seq1 = seq1 + row.strip("\n")
    
    with open(sys.argv[2],'r') as fasta_file2:
    # seq1=fasta_file1.readlines()
    # seq1=str(seq1)
    # seq1=seq1.strip('\n')
        seq2 = ""
        headerline = True
        for row in fasta_file2:
            if headerline:
                headerline = False
            else:
                seq2 = seq2 + row.strip("\n")# Load seq2

else:
    with open("../data/407228326.fasta",'r') as fasta_file1:
    # seq1=fasta_file1.readlines()
    # seq1=str(seq1)
    # seq1=seq1.strip('\n')
        seq1 = ""
        headerline = True
        for row in fasta_file1:
            if headerline:
                headerline = False
            else:
                seq1 = seq1 + row.strip("\n")
    
    
    with open("../data/407228412.fasta",'r') as fasta_file2:
    # seq1=fasta_file1.readlines()
    # seq1=str(seq1)
    # seq1=seq1.strip('\n')
        seq2 = ""
        headerline = True
        for row in fasta_file2:
            if headerline:
                headerline = False
            else:
                seq2 = seq2 + row.strip("\n")# Load seq2


# with open(sys.argv[1],'rb') as fasta_file2:
#     seq2=fasta_file2.readlines()
#     seq2=str(seq2)
#     seq2=seq2.strip('\n')
# Two example sequences to match

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    print(score) 
    # print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

readytowrite=[]
for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z == my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z
        readytowrite.append(my_best_align)
        readytowrite.append(s1)
        readytowrite.append("")
        readytowrite.append("Best score:"+ str(my_best_score))
        readytowrite.append("")
    
    elif z >  my_best_score:
        readytowrite=[]
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z
        readytowrite.append(my_best_align)
        readytowrite.append(s1)
        readytowrite.append("")
        readytowrite.append("Best score:"+ str(my_best_score))
        readytowrite.append("")

f = open('../results/alignment_better_output.p','wb')
pickle.dump(readytowrite,f)

# f.write(i) ## Add a new line at the end
f.close()

def main(argv):
    print(my_best_align)
    print(s1)
    print("Best score:", my_best_score)

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)


**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
473
471
465
471
462
472
520
490
492
473
491
472
477
481
489
493
462
490
480
485
477
495
524
490
494
441
514
482
514
473
491
484
510
457
489
476
479
480
480
497
518
498
498
478
492
488
476
465
466
499
480
518
487
501
501
467
463
501
502
471
517
482
520
492
490
504
457
511
478
505
501
488
518
500
495
463
545
475
504
466
496
495
491
496
480
514
484
488
487
504
497
472
507
460
518
499
488
483
487
475
497
510
495
478
503
501
502
479
518
473
484
494
509
498
474
498
480
506
474
487
485
495
487
497
498
5
**********************************************************************

Code ran without errors

Time consumed = 5.02446s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 
taxa_dic={}

for i in taxa:
        taxa_dic.setdefault(i[1],set()).add(i[0])


print (taxa_dic)

**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 97

Output (only first 500 characters): 

**********************************************************************
{'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'}, 'Chiroptera': {'Myotis lucifugus'}, 'Rodentia': {'Cleithrionomys rutilus', 'Peromyscus crinitus', 'Gerbillus henleyi', 'Mus domesticus'}, 'Carnivora': {'Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella'}}

**********************************************************************

Code ran without errors

Time consumed = 0.05383s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
def creatabug(x):
    y= x ** 4
    z= 0.
    y=y/z
    return y
creatabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 96

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "debugme.py", line 6, in <module>
    creatabug(25)
  File "debugme.py", line 4, in creatabug
    y=y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
_a_global = 10

def a_function():
    _a_global=5
    _a_local=4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()

print("Outside the function the value is ", _a_global)


_a_global=10

def a_function():
    global _a_global
    _a_global=5
    _a_local=4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()

print("Outside the function the value is ", _a_global)




_a_global=10 #define a global variable

if _a_global >=5: #condition
    _b_global =_a_global+5 #action

def _a_function(): #defining a function
    _a_global = 5 #local variable
    if _a_global >= 5: #local condition
        _b_global = _a_global + 5 #local action
        _a_local = 4  #define a local variable
    print("Inside the function, the value of global _a_ is ", _a_global)
    print("Inside the function, the value gllobal _b_ is ", _b_global)
    print("Inside the function, the value is local _a_ is ", _a_local)
    return None

_a_function()

print("Outside the function the value of global a is ", _a_global)
print("Outside the function the value of global b is ", _b_global)**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 95

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function the value is  10
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function the value is  5
Inside the function, the value of global _a_ is  5
Inside the function, the value gllobal _b_ is  10
Inside the function, the value is local _a_ is  4
Outside the function the value of global a is  10
Outside the function the value of global b is  15

**********************************************************************

Code ran without errors

Time consumed = 0.02747s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)
**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 94

Output (only first 500 characters): 

**********************************************************************
{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.03185s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env ppython3
"""these functions can manipulate input data"""
import sys
# What does each of foo_x do? 
def foo_1(x=1):
    return x ** 0.5


def foo_2(x=1, y=2):
    if x > y:
        return x
    return y

def foo_3(x=3, y=1, z=2):
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]


def foo_4(x=1):
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result


def foo_5(x=5): # a recursive function that calculates the factorial of x
    if x == 1:
        return 1
    return x * foo_5(x - 1)


def foo_6(x=3): # Calculate the factorial of x in a different way
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto

def main(argv):
    print(foo_1(2))
    print(foo_2(3,6))
    print(foo_3(3,1,6))
    print(foo_4(4))
    print(foo_5(4))
    print(foo_6(4))
    return None

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Missing docstrings in one more functions!
.5 pt deducted per missing docstring

Current Points = 86.5

Output (only first 500 characters): 

**********************************************************************
1.4142135623730951
6
[1, 3, 6]
24
24
24

**********************************************************************

Code ran without errors

Time consumed = 0.02533s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!\
for i in birds:
    print(i,end="\n")

**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 85.5

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)
('Delichon urbica', 'House martin', 19)
('Junco phaeonotus', 'Yellow-eyed junco', 19.5)
('Junco hyemalis', 'Dark-eyed junco', 19.6)
('Tachycineata bicolor', 'Tree swallow', 20.2)

**********************************************************************

Code ran without errors

Time consumed = 0.02838s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 
latin=[x[0] for x in birds]
print (latin)

common=[x[1] for x in birds]
print (common)

masses=[x[2] for x in birds]
print (masses)

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 
for i in range(3):
    lists=[x[i] for x in birds]
    print(lists)

**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 84.5

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.05382s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
import csv
import sys
import doctest
 
#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus' 
    >>> is_an_oak('Fraxinus excelsior')
    False

    >>> is_an_oak('Quercus cerris')
    True

    >>> is_an_oak('Quercus petraea')
    True

    >>> is_an_oak('Pinus sylvestris')
    False
    """
    if 'quercus' in name.lower():
        return True
    else:
        return False


def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../data/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    csvwrite.writerow(['Genus', 'species']) 
    oaks = set()
    for row in taxa:
        if row[0] != ('Genus'):
            print(row)
            print ("The genus is: ") 
            print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.09802s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 83.5

Output (only first 500 characters): 

**********************************************************************
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'Quercus cerris', 'Quercus robur', 'Quercus petraea'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}
{'QUERCUS PETRAEA', 'QUERCUS CERRIS', 'QUERCUS ROBUR'}

**********************************************************************

Code ran without errors

Time consumed = 0.03994s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
for i in range(5):
    print(i)


my_list = [0,2,"geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0,1,11,111,1111]
for s in summands:
    total =total +s
    print(total)

z=0
while z<100:
    z=z+1
    print(z)

**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 82.5

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********************************************************************

Code ran without errors

Time consumed = 0.02853s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Filename: using_name.py
if __name__=="__main__":
    print('This program is being run by itself')
else:
    print('I am being imported from other modelue')**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 81.5

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.02732s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Two example sequences to match
import csv
path="../data/twosequences.csv"
with open(path)as csvfile:
    reader =csv.reader(csvfile)
    rows=list(row for row in reader)
# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

seq1="".join(rows[0])
seq2="".join(rows[1])

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score)
f = open('../results/alignment_output.txt','w')
f.write(my_best_align + "\n"+s1+"\n"+"Best score:"+ str(my_best_score)) ## Add a new line at the end
f.close()
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 80.5

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4
 
.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5
 
........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.........--*---*
.........CAATTCGGAT
ATCGCCGG
**********************************************************************

Code ran without errors

Time consumed = 0.02804s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************
#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()


**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 79.5

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.02882s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************

#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))


**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 78.5

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.04441s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""This scrpit can work out the matches of two alignments, and out put the best match"""
import sys


if len(sys.argv) == 3:
    with open(sys.argv[1],'r') as fasta_file1:
        seq1 = ""
        headerline = True
        for row in fasta_file1:
            if headerline:
                headerline = False
            else:
                seq1 = seq1 + row.strip("\n")
    
    with open(sys.argv[2],'r') as fasta_file2:
        seq2 = ""
        headerline = True
        for row in fasta_file2:
            if headerline:
                headerline = False
            else:
                seq2 = seq2 + row.strip("\n")# Load seq2

else:
    with open("../data/407228326.fasta",'r') as fasta_file1:
        seq1 = ""
        headerline = True
        for row in fasta_file1:
            if headerline:
                headerline = False
            else:
                seq1 = seq1 + row.strip("\n")
    
    
    with open("../data/407228412.fasta",'r') as fasta_file2:
        seq2 = ""
        headerline = True
        for row in fasta_file2:
            if headerline:
                headerline = False
            else:
                seq2 = seq2 + row.strip("\n")# Load seq2

# Two example sequences to match

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 

def main(argv):
    print(my_best_align)
    print(s1)
    print("Best score:", my_best_score)
    f = open('../results/alignment_fasta_output.txt','w')
    f.write(my_best_align + "\n"+s1+"\n"+"Best score:"+ str(my_best_score)) ## Add a new line at the end
    f.close()

if (__name__ == "__main__"):
    status =main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
............................................................................AAAAAAACAAAAAGATACATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATATACATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCA
**********************************************************************

Code ran without errors

Time consumed = 4.37686s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
"""some functions exwmplifying the use of control statements """
##docstring, would be shown in help()
_appname_="boilerplate"
_author_="ys"
_version_="0.0.1"
_license_="code.program"

import sys ##introduce a modelue

def even_or_odd(x=0): # if not specified, x should take value 0.
##(x=0, set a default)
    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

#even_or_odd(7653)


def largest_divisor_five(x=120):
    ##default value x=120
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    #alined in order from large to small to achieve the function largest divisor.
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
        ##if we got retur here whole processes will be stoped
    return "The largest divisor of %d is %d" % (x, largest)

#largest_divisor_five(112)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            #if x can be divided by any number between 2 and x, it is not a prime
          print("%d is not a prime: %d is a divisor" % (x, i)) 
          return False
    print("%d is a prime!" % x)
    return True
    #if return True is necessary? NO, you could return None, it will still print it's a prime, but you have to return something.
    ##however if i am using while True, use return false would allow sme to cease the proccess.

#is_prime()
#is_prime(31)

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        ##allows all the numbers between 2(smallest prime) and x be divided by x 
      if is_prime(i):
          #using the function that set up just now
        allprimes.append(i)
        #
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

#find_all_primes()
#find_all_primes(100)

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02903s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""

__author__ = 'Your Name (Your.Name@your.email.address)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    """
    
    #Define function to be tested
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### I SUPPRESSED THIS BLOCK: WHY? #######

# def main(argv): 
#     print even_or_odd(22)
#     print even_or_odd(33)
#     return 0

# if (__name__ == "__main__"):
#     status = main(sys.argv)
############################################

doctest.testmod()   # To run with embedded tests**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06324s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 77.5

Output (only first 500 characters): 

**********************************************************************
 First Line

 Second Line



 Third Line



 Fourth Line



 

 First Line

 Second Line

 Third Line

 Fourth Line


**********************************************************************

Code ran without errors

Time consumed = 0.02847s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 77.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!